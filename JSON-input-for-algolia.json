{
    "authors": [
      "Ladislav Prskavec"
    ],
    "categories": [],
    "content": "On OpenTelemetry website, you can read the definition what is OpenTelemetry:\nOpenTelemetry is a collection of APIs, SDKs, and tools. Use it to instrument, generate, collect, and export telemetry data (metrics, logs, and traces) to help you analyze your software\\u0026rsquo;s performance and behavior.\nIt is not vendor free way to instrument your code. In Go, we don\\u0026rsquo;t have in Oct 2023 full support. Traces, metrics, logs, are not in the stable version. You can still start using it, at least for traces and metrics.\nI\\u0026rsquo;m working on a project in which I need to make traces from Python to my Go API, and we want all stored in logs and traces. I started with Gin framework, which is my default simple framework for APIs. There are many good alternatives, but I like to use this one.\nIt\\u0026rsquo;s great if you Google otel gin you get otelgin library for instrument your code.\nYou find good example where you see how to use it.\nr.Use(otelgin.Middleware(\\u0026#34;my-server\\u0026#34;)) You add a new line to your code with otelgin middleware, and you are done! Or not?\nContext Propagation If you need to connect traces across services, you need setup propagation, and you find in every example of your tracer.\notel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{})) I will focus on propagation.TraceContext{}. TraceContext is W3C spec on how to pass information about TraceId, SpanId across services in Header traceparent. All work for you if you call another system. But it doesn\\u0026rsquo;t work for me.\nI tested with this command:\ncurl -H \\u0026#34;traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01\\u0026#34; http://localhost:8080 I can\\u0026rsquo;t find my correct traceId in my logs.\nYou need to configure otelgin middleware with the propagator too. Not just tracer.\notelginOption := otelgin.WithPropagators(propagation.TraceContext{}) r.Use(otelgin.Middleware(\\u0026#34;my-server\\u0026#34;, otelginOption)) After that, all start working.\nHow to debug it? I use two ways to debug.\nFirst, I\\u0026rsquo;m using otel-desktorp-viewer to debug traces locally without running an observability server.\nSecond, I\\u0026rsquo;m using log/slog library for logging (available in Go 1.21+). I make simple logging middleware for Gin that records traceId and spanId.\nfunc GinSlogMiddleware(logger *slog.Logger) gin.HandlerFunc { return func(c *gin.Context) { start := time.Now().UTC() path := c.Request.URL.Path query := c.Request.URL.RawQuery c.Next() ctx := c.Request.Context() end := time.Now().UTC() latency := end.Sub(start) fields := slog.Group(\\u0026#34;http\\u0026#34;, slog.Int(\\u0026#34;status\\u0026#34;, c.Writer.Status()), slog.String(\\u0026#34;method\\u0026#34;, c.Request.Method), slog.String(\\u0026#34;path\\u0026#34;, path), slog.String(\\u0026#34;query\\u0026#34;, query), slog.String(\\u0026#34;ip\\u0026#34;, c.ClientIP()), slog.String(\\u0026#34;user-agent\\u0026#34;, c.Request.UserAgent()), slog.Duration(\\u0026#34;latency\\u0026#34;, latency), ) if len(c.Errors) \\u0026gt; 0 { for _, e := range c.Errors.Errors() { logger.ErrorContext(ctx, e, fields) } } else { logger.InfoContext(ctx, path, fields) } } } You can see that the key is logging with Context, which contains information about traces. Context handler will log information about traces.\ntype ContextHandler struct { slog.Handler } func (h ContextHandler) Handle(ctx context.Context, r slog.Record) error { r.AddAttrs(h.addTraceFromContext(ctx)...) return h.Handler.Handle(ctx, r) } func (h ContextHandler) addTraceFromContext(ctx context.Context) (as []slog.Attr) { if ctx == nil { return } span := trace.SpanContextFromContext(ctx) traceID := span.TraceID().String() spanID := span.SpanID().String() traceGroup := slog.Group(\\u0026#34;trace\\u0026#34;, slog.String(\\u0026#34;id\\u0026#34;, traceID)) spanGroup := slog.Group(\\u0026#34;span\\u0026#34;, slog.String(\\u0026#34;id\\u0026#34;, spanID)) as = append(as, traceGroup) as = append(as, spanGroup) return } And my logger init looks as this:\nfunc InitLog() *slog.Logger { jsonHandler := slog.NewJSONHandler(os.Stdout) ctxHandler := ContextHandler{jsonHandler} return slog.New(ctxHandler) } You can make a custom JSONHandler if you need to override the logging format, for example, for support Elastic ECS if your destination is Elastic stack.\nResources and libraries supporting log/slog aren\\u0026rsquo;t always ready, but I expected that will resolved in the future.\n",
    "date": 1697875614,
    "expirydate": -62135596800,
    "kind": "page",
    "lang": "en",
    "lastmod": 1697875614,
    "objectID": "94ca1a5bb9d4a524a3c38c23bea4bc5d",
    "permalink": "https://www.prskavec.net/post/otel-gin-go/",
    "publishdate": "2023-10-21T09:06:54+01:00",
    "relpermalink": "/post/otel-gin-go/",
    "section": "post",
    "summary": "How make W3Context work for your application in Go Gin Framework",
    "tags": [
      "otel",
      "go"
    ],
    "title": "OpenTelemetry and Go Gin Framework",
    "type": "post"
  }
